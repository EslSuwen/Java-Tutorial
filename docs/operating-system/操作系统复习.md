# 操作系统复习

> 本文由本人学习过程中总结，难免有纰漏，欢迎交流学习

## 目录

#### [第1章 操作系统引论](#第1章 操作系统引论)

#### [第2章 进程管理](#第2章 进程管理)

#### [第3章  处理机调度与死锁](#第3章  处理机调度与死锁)

#### [第4章 存储器管理](#第4章 存储器管理)

#### [第5章  设备管理](#第5章  设备管理)

#### [第6章  文件管理](#第6章  文件管理)

#### [附习题及答案](#附习题及答案)

</br>
</br>

<span id='chapter1'></span>

## 第1章 操作系统引论

操作系统的地位：紧贴系统硬件之上，所有其他软件之下（是其他软件的共同环境）

### 操作系统目的/目标

 使计算机系统更易于使用（方便性）。
 以一种效率的方式使用资源（有效性）.
 采用模块化结构,易于增、删、改（可扩充性）。
 要求统一开放的环境，能通过网络集成化并正确、有效地协同工作，实现应用程序的移植（开放性）



### 操作系统的作用

 Os作为用户与计算机硬件系统之间的接口。
 OS作为计算机系统资源的管理者。
 OS用作扩充机器 



### 操作系统的基本特征

 并发(concurrence)
 共享(sharing)
 虚拟(virtual)
 异步性(asynchronism)



并发(concurrence)：指在计算机系统中同时存在着多道运行的程序（进程）
                   宏观上：多道程序同时在执行
                   微观上：任何时刻只有一道程序在执行，即微观上多道程序在CPU上轮流（交替）执行（单机）
并行(parallel)： 与并发相似，指多道程序在同一时刻执行，
                                   但需多个硬件支持。                                       
     注：1、程序的并发执行能有效改善系统资源的利用率，但使系统复杂化，因此操作系统必须对并发活动进行控制和管理。
             2、并发是操作系统最重要的特征，其它特征均以并发为前提。

共享(sharing)系统中的资源不再为某道程序所独占，而
        是供多道程序共同使用。
资源共享方式：互斥共享式、同时访问式

并发和共享是操作系统的两个最基本的特征 
 二者互为存在条件：
         资源的共享是以程序的并发执行为条件。
         程序的并发执行也以资源的共享为条件。

虚拟(virtual)把一个物理实体映射为若干个对应的逻辑实体——分时或分空间。
虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。如：虚拟处理机、虚拟存储器、虚拟设备

异步性(asynchronism)也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的。

#### 操作系统的功能

##### 处理机管理

处理机管理的主要任务：
是对处理机进行分配
对处理机运行进行有效的控制和管理
注：处理机的分配和运行以进程为基本单位，因此对处理机的管理可归结为对进程的管理
处理机管理的功能
进程控制
进程同步
进程通信
调度

##### 存储器管理

主要任务
为多道程序的运行提供良好的环境
方便用户使用存储器
提高存储器的利用率
从逻辑上扩充内存
功能
内存分配
内存保护
地址映射
内存扩充



##### 设备管理

主要任务
完成用户提出的I/O请求
为用户分配I/O设备
提高I/O设备的利用率及速度
方便用户使用I/O设备
功能
缓冲管理
设备分配
设备处理
虚拟设备

##### 文件管理

主要任务
对用户文件和系统文件进行管理
方便用户使用文件
保证文件的安全性
功能
文件存储空间的管理
目录管理
文件的读、写管理
文件的共享与保护

##### 用户接口

主要任务
方便用户使用操作系统
功能
命令接口
程序接口（系统调用）
图形接口

##### 单道批处理系统

1、工作流程：
   （1）作业合成一批输入到外存上，同时在系统中配上监控程序。
     （2）monitor将作业逐个送入内存并运行。
2、特征：（1）自动性  （2）顺序性     （3）单道性
3、优点：减少了人工操作的时间，提高机器的利用率和系统吞吐量。
4、缺点：对某些作业来说，当它发出输入/输出请求后，CPU必须等待I/O的完成，特别因为I/O设备的低速性，从而使机器的利用率很低。 

##### 多道批处理系统

特征：（1）调度性     （2）无序性   （3）多道性
优点：（1）资源的利用率高   （2）系统吞吐量大
缺点：（1）平均周转周期长   （2）无交互能力
需解决问题
       处理机管理、内存管理、I/O设备管理、文件及作业管理问题
操作系统的形成
        为解决上述问题，在多道程序系统中增设一组软件以有效加以解决，同时增设方便用户使用计算机的软件，这样便形成了操作系统。
操作系统：是一组控制和管理计算机硬件和软件资源，合理地组织计算工作流程，以及方便用户使用的程序集合。

##### 批处理操作系统优缺点

优点：
作业流程自动化; 
效率高
吞吐量高
缺点：
无交互手段
调试程序困难

##### 实时系统

实时操作系统：指系统能及时（或即时）响应外部事件的请求，并控制所有实时任务协调一致地运行。
实时操作系统的应用领域  
    有实时要求（有严格确定的时间限制）的领域（过程控制及事务处理）
实时系统分类：
     （1）实时控制系统   （2）实时信息处理系统
实时操作系统的主要特征：实时性和可靠性；
                        多路性、独立性、交互性

##### 三种基本的操作系统

三种基本的操作系统
批处理操作系统、分时操作系统和实时操作系统
通用操作系统
如果一个操作系统兼有批处理、分时和实时系统三者或二者的功能 ，则称该操作系统为通用操作系统。

### 微机操作系统

###### 微机操作系统的特征

应用领域：事务处理、个人娱乐，
系统要求：使用方便、支持多种硬件和外部设备（多媒体设备、网络、远程通信）、效率不必很高。

###### 常用的微机操作系统

单用户单任务：CP/M，MS- DOS
单用户多任务：OS/2, Windows 
多用户多任务：UNIX, Solaris x86, Linux。

### 多处理机操作系统

###### 多处理机系统引入原因

增加系统的吞吐量
节省投资
提高系统的可靠性

###### 多处理机系统的类型

紧密耦合MPS
松散耦合MPS

###### 多处理机操作系统的类型

非对称多处理模式
对称多处理模式

### 网络操作系统

###### 计算机网络的类型

###### 网络OS的模式

客户/服务器模式
对等模式

###### 网络OS的功能

通信、资源管理、网络服务、网络管理、互操作能力

#### 并行系统

##### 并行系统： 多于一个CPU的多处理机系统。

##### 并行系统的优点

增大吞吐量：能在更短的时间内完成更多的工作。
经济：共享许多设备（内存，总线等）
提高可靠性：当一个CPU出故障时，会将部分工作分给其它CPU，从而不会使整个系统停机，只是降低了速度而已。

### 分布式操作系统

##### 分布式系统：能将任务处理和控制进行分散/分布的系统（相对于集中式）。

##### 分布式系统的两种环境：多处理系统；多计算机系统。

##### 分布式OS与网络OS的比较

​    1.分布性       2.并行性    3.透明性 
​    4.共享性       5.键壮性
​         分布式系统基本特征---处理上的分布，即功能和任务的分布。

### 模块化操作系统结构

OS是采用“模块化程序设计”技术，按其功能划分为若干个独立的模块，管理相应的功能，同时规定好各模块之间的接口，以实现其交互，对较大模块又可按子功能进一步细分下去。所以这种OS称为模块化OS结构。

##### 优点

提高了OS设计的正确性、可理解性和可维护性
增强了OS的可适用性
加速了OS的开发过程

##### 缺点：

模块及接口划分较困难
未区别共享资源和独占资源
由于管理的差异，使OS结构变得不够清晰

##### Linux（多用户、多任务OS）

### 微内核的OS结构

##### 微内核技术的主要思想

​          在OS内核中只留下一些最基本的功能，而将其他服务分离出去，由工作在用户态下的进程来实现，形成所谓“客户/服务器”模式。客户进程可通过内核向服务器进程发送请求，以取OS的服务。

##### 微内核

​      精心设计的，能实现现代OS核心功能的小型内核，它小而精炼，运行在核心态下，开机后常驻内存，不会因内存紧张而换出，它为构建通用OS提供了一个重要基础。

##### 微内核的基本功能

进程管理
存储器管理
进程通信管理
I/O设备管理

##### 特点

小而精练
系统的灵活性和可扩充性好
系统的可靠性高
适用于分布式系统

##### windows 2000/XP、UNIX、嵌入式OS



<span id='chapter2'></span>

## 第2章 进程管理

###  程序顺序执行

##### 程序执行时，必须按照某种先后次序逐个执行

Eg     s1:  a:=x+y
          s2:  b:=a-5
          s3:  c:=b+1

##### 程序顺序执行时有如下特征：

顺序性
封闭性
可再现性

### 程序并发执行

##### 程序并发执行时的特征

间断性
失去封闭性
不可再现性


### 进程的定义、特征

#### 1、进程process的定义

   1）进程是程序的一次执行。
   2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
   3）进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位。

##### 注：进程与程序的主要区别

#### 进程与程序的主要区别

1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态概念。
2）程序的存在是永久的。而进程则是有生命期的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。
3）程序仅是指令的有序集合。而进程则由程序段、相关数据段和进程控制块（PCB）组成。
4）进程与程序之间不是一一对应。

|            |                     程序                      | 进程              |
| ---------- | :-------------------------------------------: | :---------------- |
| 概念       |                     静态                      | 动态              |
| 所在存储器 |                     外存                      | 内存              |
| 存在时间   |                     永久                      | 有生命期          |
| 组成       |                   有序指令                    | 程序段,数据段,PCB |
| 对应关系   | 一个程序可对应多个进程 一个进程可对应多个程序 | Same              |

#### 进程process的基本特征



#####  （1）结构特征

​           为了描述和记录进程的运动变化过程，并使之能正确运行，每个进程都应配置了一个进程PCB。所以，从结构上看，每个进程（进程实体）都是由程序段、相关数据段及进程控制块（PCB）组成。
注：1.在早期UNIX版本中称进程的三个组成部分为“进程映像”
​       2.区别进程实体和进程

#####  （2）动态性

​         进程的实质是程序在处理机上的一次执行过程，因此是动态性的。所以动态性是进程的最基本的特征。同时动态性还表现在 进程则是有生命期的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。

##### （3）并发性

​       指多个进程实体同时存在于内存中，能在一段时间内同时运行。
​       引入进程的目的就是为了使进程能并发执行，以提高资源利用率，所以并发性是进程的重要特征，也是OS的重要特征。

##### （4）独立性

​       指进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。

##### （5）异步性

​        指进程以各自独立的、不可预知的速度向前推进。

### 二、 进程状态

#### 进程的5种状态（三种基本状态）

##### new新建/创建:进程正在创建中的状态

##### ready就绪:  进程已获得了除处理机以外的所有资源，等待分配处理机执行的等待状态。

##### running运行/执行: 当一个进程获得必要的资源并正在处理机上执行的状态。

##### waiting等待/阻塞:  正在执行的进程由于发生某事件而暂时无法执行下去，此时进程所处的状态。

##### terminated终止/撤消/退出：进程执行完毕，释放所占资源的状态。

进程在运行期间并非固定处于某个状态，而是不断从一个状态转换到另一个状态。

#### 三种基本状态转换：

##### (1) 就绪→执行

1. 处于就绪状态的进程，当进程调度程序为之分配了处理机后
2. 该进程便由就绪状态转变成执行状态。

##### (2) 执行→就绪


处于执行状态的进程在其执行过程中，因分配给它的一个时间
片已用完而不得不让出处理机，于是进程从执行状态转变成就
绪状态。

##### (3) 执行→阻塞


正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。

##### (4) 阻塞→就绪


处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

### 进程的挂起状态

​       在某些系统中，为了更好地管理和调度进程，引入了挂起状态：

#### 挂起状态/静止状态：

​           程序在运行期间，由于某种需要，往往要将进程暂停执行，使其静止下来，以满足其需要。这种静止状态就称为进程的挂起状态。

#### 引起挂起状态的原因

##### 终端用户的需要：

终端用户在自己程序运行中发现问题要求使正在执行的进程暂停执行而使进程处于挂起状态。

##### 父进程的需要：

父进程为了考查和修改某个子进程，或者协调各子进程间的活动，需要将该子进程挂起。

##### 操作系统的需要：

操作系统为了检查运行中的资源使用情况或进行记帐，而将某些进程挂起。

##### 对换的需要：

为了提高内存的利用率，而将内存中某些进程挂起，以调进其它程序运行。

##### 负荷调节的需要：

由于工作负荷较重，而将一些不重要的进程挂起，以保证系统能正常运行（实时操作系统）

#### 具有挂起状态的进程状态

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143706070-1351390210.png)


### 进程控制块Process Control Block (PCB)

进程控制块PCB
      是操作系统为了管理和控制进程的运行而为每一个进程定义的一个数据结构，它记录了系统管理进程所需的全部信息。系统根据PCB而感知进程的存在，PCB是进程存在的唯一标志。

#### 1、进程控制块PCB的作用

1. 是OS对并发执行的进程进行控制和管理的根据。
2. 也是系统用来感知进程存在的根据，即PCB是进程存在的唯一标志。

#### 2、进程控制块PCB中的信息

 根据操作系统的要求不同，PCB所包含信息有些不同，但通常包含以下信息：

##### 进程标志符：

由系统创建进程时分配给进程的唯一标识号，通常为一整数，称为进程号，用于区分不同的进程。其所属用户通常也为一整数，称为用户号。

##### 处理机状态（断点信息）：

即处理机中各种寄存器（通用寄存器、PC、PSW等）的内容

##### 进程调度：

记录了进程调度的相关信息（状态、优先级、事件等）。

##### 进程控制：

记录了系统对进程控制的信息（程序和数据的地址、同步机制、资源清单、链接指针）

#### 3、进程控制块PCB的组织方式

   在一个系统中，通常存在着许多进程，它们所处的状态不同，为了方便进程的调度和管理，需要将各进程的PCB用适当方法组织起来。目前常用的组织方式有：

##### 链接方式          图示

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143714207-1275160792.png)


​    把同一状态的PCB链接成一个队列，这样就形成了就绪队列、阻塞队列等。

##### 索引方式          图示 

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143721182-217202540.png)


​      将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB ，不同状态对应不同的索引表。     

###  进程的控制

进程控制是进程管理中最基本的功能，即对系统中所有的进程实施有效的管理，其功能包括进程的创建、撤消、阻塞与唤醒等，这些功能一般是由操作系统的内核来完成。

#### OS 内核：

在现代OS中，常把一些功能模块（与硬件紧密相关的、常用设备的驱动程序及运行频率较高的）放在紧靠硬件的软件层次中，加以特殊保护，同时把它们常驻内存，以提高OS的运行效率，这部分功能模块就称OS的内核。内核是基于硬件的第一层软件扩充，它为系统控制和管理进程提供了良好的环境。

#### 处理机的执行状态

为防止OS及其关键数据（如PCB等)不被用户有意或无意破坏,通常将处理机的执行状态分为两种

| 处理机状态     | 特权(执行指令,访问）         | 程序     |
| -------------- | ---------------------------- | -------- |
| 系统态(核心态) | 较高(一切指令,所有R及存储区) | OS内核   |
| 用户态         | 较低(规定指令,指定R及存储区) | 用户程序 |

### 进程创建

一个进程可以创建若干个新进程，新创建的进程又可以创建子进程，为了描述进程之间的创建关系，引入了进程图（如下图所示：）

####   1、进程图：

又称为进程树或进程家族树，是描述进程家族关系的一棵有向树。

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143729018-341083733.png)


#### 2、引起进程创建的事件

  在多道程序环境中，只有进程才可以在系统中运行。为了使一个程序能运行，必须为它创建进程。导致进程创建的事件有：
  用户登录：在分时OS中，用户在终端键入登录命令后，如是合法用户，则系统为该终端创建一进程，并插入就绪队列。
  作业调度：在批处理OS中，当按某算法调度一作业进内存，系统为之分配必要资源，同时为该作业创建一进程，并插入就绪队列。
 提供服务：在程序运行中，若用户需某种服务，则系统创建一进程为用户提供服务，并插入就绪队列。
  应用请求：在运行中，由于应用进程本身的需求，自己创建一进程，并插入就绪队列。

#### 3、进程的创建

操作系统一旦发现了要求创建进程的事件后，便调用进程创建原语create()按以下过程创建一新进程：

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143735227-1134513950.png)


###    二、进程的撤消

  一个进程在完成其任务后，应加以撤消，以便及时释放其占有的各类资源。

#### 1、导致进程撤消的事件

进程正常结束
进程异常结束
外界干预
       如果系统中发生了要求撤消进程的事件，OS便调用撤消原语去撤消进程。

#### 2、撤消原语可采用2种撤消策略：

只撤消指定的进程
撤消指定进程及其所有的子孙进程

####  3、进程撤消的过程

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143742218-1630570027.png)


### 三、进程的阻塞与唤醒

  当一个进程期待的事件尙未出现时，该进程调用阻塞原语block()（功能：将进程由执行状态转为阻塞状态）将自己阻塞起来。对于处于阻塞状态的进程，当该进程期待的事件出现时，由其它相关进程调用唤醒原语wakeup()（功能：将进程由阻塞状态变为就绪状态）将阻塞的进程唤醒，使其进入就绪状态。

#### 1、引起进程阻塞和唤醒的事件

1. 请求系统服务
2. 启动某种操作
3. 新数据尚未到达
4. 无新工作可做

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143759957-1356523466.png)

#### 四、进程的挂起与激活

​     当引起进程挂起的事件发生时，系统就将利用挂起原语suspend()将指定进程或处于阻塞状态的进程挂起。当发生激活进程的事件时，系统就将利用激活原语active()将指定进程激活。

##### 1、引起进程的挂起与激活的事件

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143826260-1393300638.png)


### 进程同步

进程同步是指对多个相关进程在执行次序上进行协调，它的目的是使系统中诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性；或系统中诸进程之间在逻辑上的相互制约的关系（直接的-同步；间接的—互斥）。
用来实现同步的机制称为同步机制。如：信号量机制；管程机制。

#### 进程同步的基本概念

两种形式的制约关系
临界资源、临界区
同步机制应遵循的规则

#### 信号量机制

整型信号量
记录型信号量
AND型信号量集、一般信号量集

#### 信号量的应用

信号量实现进程互斥
信号量描述进程间的前趋关系

#### 一、进程同步的基本概念

##### 1、两种形式的制约关系

系统中诸进程之间在逻辑上存在着两种制约关系：
直接制约关系（进程同步）：即为完成同一个任务的诸进程间，因需要协调它们的工作而相互等待、相互交换信息所产生的直接制约关系。    
间接制约关系（进程互斥） ：是进程共享独占型资源而必须互斥执行的间接制约关系。
同步与互斥比较

| 同 步                                                    | 互  斥                         |
| ------------------------------------------------------------ | ---------------------------------- |
| 进程-进程                                                    | 进程-资源-进程                     |
| 时间次序上受到某种限制                                       | 竞争到某一物理资源时不允许进程工作 |
| 相互清楚对方的存在及作用，交换信息                           | 不一定清楚其进程情况               |
| 往往指有几个进程共同完成一个任务                             | 往往指多个任务多个进程间通讯制约   |
| 例：生产与消费之间，发送与接受之间，作者与读者之间，供者与用者之间 | 例：交通十字路口，单轨火车的拨道岔 |

##### 2、临界资源、临界区

一次只允许一个进程使用的资源称为临界资源，如打印机，绘图机；变量，数据等，诸进程间采取互斥方式式实现对这种临界资源的共享，从而实现并行程序的封闭性。
例：有两个进程A和B，它们共享一个变量x，且两个进程按以下方式对变量X进行访问和修改:
A:  R1=X;
     R1=R1+1;
       X=R1;
B:  R2=X;
     R2=R2+1;
       X=R2;
          其中R1和R2为处理机中的两个寄存器。A与B均对X+1，即X+2。
若按另一顺序对变量进行修改：

A:  R1=X;
B:  R2=X;
A:  R1=R1+1;
     X=R1;
B:  R2=R2+1;
     X=R2;
结果x只加了1.

（1）变量X必需按临界资源处理。
（2）每个进程中访问临界资源的那段代码称为临界区

  为了保证临界资源的正确使用，可以把临界资源的访问过程分成以下几部分：                    

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143833694-226812400.png)


进入区—增加在临界区前面的一段代码，用于检查欲访问的临界资源此刻是否被访问。
退出区—增加在临界区后面的一段代码，用于将临界资源的访问标志恢复为未被访问标志。
剩余区—进程中除了进入区、临界区及退出区之外的其余代码。

###### 要进入临界区的若干进程必须满足：

（1）一次只允许一个进程进入临界区
（2）任何时候，处于临界区的进程不得多于一个
（3）进入临界区的进程要在有限的时间内退出
（4）如果不能进入自己的临界区，则应让出处理机资源

###### 解决临界区（互斥）问题的几类方法：

> 同步机制

（1）软件方法
（2）硬件方法
（3）P-V操作

##### 3、同步机制应遵循的规则

###### 有空让进(空闲让进）:

当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。

###### 互斥（忙则等待）:

当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问

###### 有限等待:

对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态.

###### 让权等待:

当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”。

#### 二、信号量机制  

n信号量机制是荷兰科学家E.W.Dijkstra在1965年提出的一种同步机制，也称为P、V操作。由最初的整型信号量发展为记录型信号量，进而发展为信号量集。

n整型信号量

n记录型信号量

信号量集     （AND信号量集、一般信号量集）

n基本思想

​    1、设置一个代表资源数目的整型变量value（资源信号量）

​    2、设置一链表L用于链接所有等待的进程

§记录型信号量的数据结构

​        Type semaphore=record

​                   value:integer;

​                   L: list of process;

​                end

§wait和signal操作描述：

​      wait(S)：  S.value:=S.value-1;   

​            if S.value<0 then block(S.L);

​      signal(S): S.value:=S.value+1;  

​            if S.value£0 then wakeup(S.L);

做到“让权等待”。 

####      三、信号量的应用  

##### 利用信号量实现进程互斥(进程互斥)

利用信号量可以方便地解决临界区问题（进程互斥）。为临界资源设置一互斥信号量mutex，初值为1，则实现进程P1和P2互斥的描述：

P1进程

​     wait(mutex);

​     critical section;

​     signal(mutex);



P2进程

​     wait(mutex);

​     critical section;

​      ignal(mutex);  

###  1、生产者消费者问题

#### 设置两个同步信号量及一互斥信号量

empty：说明空缓冲单元的数目，其初值为有界缓冲区的大小n。
Full：    说明满缓冲单元的数目（即产品数目），其初值为0.
Mutex:  说明该有界缓冲区是一临界资源，必须互斥使用，
        其初值为1。

#### “生产者—消费者”问题的同步算法描述

 semaphore  full=0;  / 表示满缓冲区的数目 /
 semaphore  empty=n;  / 表示空缓冲区的数目 /
 semaphore  mutex=1;  / 表示对缓冲区进程操作的互斥信号量 /
Main()
{
  cobegin
     producer();
     consumer();
  coend
 }

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143843878-843256517.png)


#### “生产者-消费者”问题中应注意

1. 互斥信号量的P,V操作在每一程序中必须成对出现.
2. 资源信号量(full,empty)也必须成对出现,但可分别处于不同的程序中.
3.  多个P操作顺序不能颠倒.
4.  先执行资源信号量的P操作,再执行互斥信号量的P操作,否则可能引起进程死锁.
5.  它是一个同步问题：
   （1）消费者想要取产品，有界缓冲区中至少有一个单元是满的。
   （2）生产者想要放产品，有界缓冲区中至少有一个是空的。
6.  它是一互斥问题：
     有界缓冲区是临界资源，因此，各生产者进程和各消费者进程必须互斥执行。

### 2、“哲学家进餐”问题

 semaphore  stick[5]={1,1,1,1,1};  / 分别表示5支筷子 /
 Main()
{
  cobegin
     philosopher(0);
     philosopher(1);
     philosopher(2);
     philosopher(3);
     philosopher(4);
  coend
 }

#### 第i个哲学家的活动算法

philosopher(int i)

{
  while(true)
   {
        思考;  
    p(stick[i]); 
    P(stick[(i+1)%5]); 
    进餐； 
    V(stick[i]);
    V(stick[(i+1)%5]);
}
}

####   说明：  

1、此算法可以  保证不会有相邻的两位哲学家同时进餐  。

2、若五位哲学家同时饥饿而各自拿起了左边的筷子，这使五个信号量stick均为0，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去，即  可能会引起死锁  。

### 3、“读者—写者”问题

#### “读者—写者”问题的同步算法描述

#####  设置一个共享变量和两个信号量：

共享变量Readcount：记录当前正在读数据集的读进程数目，
                   初值为0。
读互斥信号量Rmutex ：表示读进程互斥地访问共享变量
                     readcount，初值为1.
写互斥信号量wmutex：表示写进程与其它进程（读、写）
                    互斥地访问数据集，初值为1.

##### “读者—写者”问题的同步算法描述

 semaphore  rmutex=1;  
 semaphore  wmutex=1; 
 int  readcount=0; 
Main()
{
  cobegin
     reader();
     writer();
  coend
 }

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143853267-456259474.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143857737-723730834.png)


### 管程的基本概念

### 进程通信—高级通信

### 线程

|                            |   进程                                                       |   线程                                                       |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|   引入      目的           |   能并发执行    ,    提高资源的利用率和系统吞吐量    .       |   提高并发执行的程度，进一步提高资源的利用率和系统吞吐量    .   |
|   并发性                   |   较低                                                       |   较高                                                       |
|   基本属性      （调度）   |   资源拥有的基本单位    —    进程      独立调度    /    分派的基本单位    —    进程   |   资源拥有的基本单位    —    进程      独立调度    /    分派的基本单位    —    线程   |
|   基本状态                 |   就绪    ;     执行    ;    等待                            |   就绪    ;    执行    ;    等待                             |
|   拥有资源                 |   资源拥有的基本单位    —    进程                            |   资源拥有的基本单位    —    进程                            |
|   系统开销                 |   创建    /    撤消    /    切换    时空开销较大             |   创建    /    撤消    /    切换时空开销较小                 |
|   系统操作                 |   创建    ,    撤消    ,    切换                             |   创建    ,    撤消    ,    切换                             |
|   存在标志                 |   进程控制块    PCB                                          |   进程控制块    PCB    ，线程控制块    TCB                   |
|   关系                     |   单进程单线程    ;    单进程多线程    ;    多进程单线程    ;    多进程多线程   |                                                              |

http://blog.sina.com.cn/s/blog_5a2bbc860101gedc.html

<span id='chapter3'></span>

## 第3章  处理机调度与死锁

​    在多道程序环境下，一个作业从提交到执行，通常都要经历多级调度，如高级调度、低级调度、中级调度等。而系统的运行性能在很大程序上取决于调度，因此调度便成为多道程序的关键。

​    在多道程序环境下，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力，然而，多个进程的并发执行也带来了新的问题----死锁。

### 一、调度的层次

一个作业从提交开始，往往要经历三级调度：高级调度、低级调度、中级调度。

#### 1、高级调度（长程/作业/宏观调度）

（1）从外存后备队列中选择作业进入就绪队列或挂起就绪. 
（2）在批处理系统中,大多配有作业调度,但在分时系统及实时系统中,一般不配置.
（3）作业调度执行频率很低,通常为几分钟一次,甚至更久。

#### 2、低级调度（短程/CPU/进程/微观调度）

（1）主要任务就是从就绪队列中选择一个进程来执行并分配处理机。
（2）是OS中最基本的调度。
（3）调度频率非常高，一般几十毫秒一次。
（4）常采用非抢占（非剥夺）方式和抢占（剥夺）方式两种。
（5）引起进程调度的因素：
进程正常终止或导常终止
正在执行的进程因某种原因而阻塞
在引入时间片的系统中，时间片用完。
在抢占调度方式中，就绪队列中某进程的优先权变得比当前正执行的进程高。

#### 非抢占式进程调度、抢占式进程调度

##### 非抢占方式：

一旦把处理机分配给某进程后，便让该进程一直执行，直到该进程完成或因某事件而被阻塞，才再把处理机分配给其它进程，决不允许某进程抢占已分配出去的处理机。
     实现简单，系统开销小，常用于批处理系统；但不利于处理紧急任务，故实时、分时系统不宜采用。

##### 抢占方式: 

允许调度程序根据某种原则（时间片、优先权、短进程优先），停止正在执行的进程，而将处理机重新分配给另一进程。
   有利于处理紧急任务，故实时与分时系统中常采用。

### 二、调度队列模型

在OS中的任何一种调度中，都将涉及到进程队列，由此形成了三种类型的调度队列模型。

1. 仅有进程调度的调度队列模型
2. 具有高级和低级调度的调度队列模型
3. 同时具有三级调度的调度队列模型

### 三、选择调度方式和算法的若干准则



在一个操作系统的设计中，应如何选择调度方式和算法，在很大程度上取决于操作系统的类型及其目标，选择选择调度方式和算法的准则有

#### 面向用户的准则

周转时间短
响应时间快
截止时间的保证
优先权准则

#### 面向系统的准则

系统吞吐量
处理机利用率好
各类资源平衡利用

#### 最优准则

最大的CPU利用率
最大的吞吐量
最短的周转时间
最短的等待时间
最短的响应时间

### 调度算法

#### 一、先来先服务调度算法FCFS

##### FCFS调度算法存在的问题

​    从表面上，先来先服务于所有作业是公平的，即按照它们到来的先后次序进程服务。但若一个长作业先到达系统，就会使许多短作业等待很长的时间，从而引起许多短作业用户的不满。

   所以，现在操作系统中，已很少用该算法作为主要调度策略，尤其是在分时系统和实时系统中。但它常被结合在其它调度策略中使用。

#### 二、短作业/进程优先调度算法SJF/SPF

##### 短作业优先调度算法（SJF）

用于作业调度
主要任务是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。

##### 短进程优先调度算法（SPF）

用于进程调度
主要任务是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它。
可采用抢占（剥夺）或者非抢占（非剥夺）调度方式。

##### SF(P)F短作业/进程优先调度的优缺点

###### 优点：

​     1）能有效降低作业的平均等待时间； 
​     2）能有效缩短进程的周转时间；

###### 缺点：

​      1）对长作业不利；
​      2）不考虑作业的紧迫程度；
​      3）作业执行时间仅为估计*；
 故SJ(P)F算法虽然是优化的，但在CPU调度中很难实现。

#### 三、时间片轮转调度算法RR—注：

（1）保证了就绪队列中的所有进程在给定的时间内，均能获得一时间片来执行，即系统在给定的时间内，响应所有用户的请求。
（2）若进程的执行时间少于时间片，则自愿释放CPU。
（3）时间片将影响：
调度算法（太长---FCFS）；
上下文切换（太短---上下文切换频繁，如下页）；
平均周转时间（如再下页）。

#### 四、优先权调度算法

##### 非抢占式优先权算法：

系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直到完成/因发生某事件而放弃处理机时，系统方可重新分配处理机。

##### 抢占式优先权算法：

系统把处理机分配给就绪队列中优先机最高的进程，使之执行。但在其执行期间，只要出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。

##### 优先权的类型

###### 静态优先权

​    优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般用一整数表示，小表优先级高。

###### 动态优先权

​     优先权在创建进程时确定，但在进程的运行期间会发生变化。 

#### 五、高响应比优先权调度算法

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143907166-61281932.png)


注：  
1)如等待时间相同,则要求服务时间愈短,其优先权愈高--SPF.
2)如要求服务时间相同,优先权决定于等待时间----FCFS。
3)对长作业,若等待时间足够长，优先权也高，也能获得CPU。

### 实时系统中的调度

#### 与实时调度相关的几个概念

就绪时间：实时任务产生并可以开始处理的时间。
开始截止时间：实时任务最迟开始处理的时间。
处理时间：实时任务处理所需要的处理机的时间。
完成截止时间：实时任务最迟完成时间。
发生周期：周期性实时任务的发生间隔时间。
优先级：实时任务相对紧廹程序。

### 死锁的基本概念

死锁 
     指多个进程在运行过程中因争夺资源而造成的一种僵局（deadly-Embrace)，若无外力作用，这些进程都将无法向前推进。

注意：
（1）参与死锁的进程数至少为2
（2）参与死锁的所有进程均等待资源
（3）参与死锁的进程至少有两个占有资源
（4）参与死锁的进程是系统中当前正在运行进程的一部分。

#### 产生死锁的原因

##### 资源分类

​    操作系统管理着系统内所有资源，它负责分配不同类型的资源给进程使用，系统中的资源从不同角度可分：

#####   根据资源本身的性质

可剥夺资源：如主存、CPU
不可剥夺资源：如驱动器、打印机等

#####   根据资源使用期限

永久性资源：可再次使用，如所有硬件。
临时性资源：消耗性的资源，如消息、信号和数据

##### 竞争资源

竞争非剥夺性资源      竞争临时性资源

#### 产生死锁的必要条件

          产生死锁必须具备以下四个条件，这四个条件是Coffman首先提出的，所以称为Coffman 条件：
* 互斥条件（资源独占条件）
* 请求和保持条件（部分分配条件）
* 不剥夺条件
* 循环等待条件（环路条件）

#### 处理死锁的基本方法

      目前处理死锁的基本方法有四种：
##### 预防死锁：

指通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。

##### 避免死锁：

指在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。

##### 检测死锁：

允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。

##### 解除死锁：

当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。

### 死锁的预防和避免方法

#### 一、死锁的预防

—— 破坏死锁的四个必要条件（常针对条件2,3,4)

##### （1）破坏互斥条件：

即允许多个进程同时访问资源。但由于资源本身固有特性限制，有的资源根本不能同时访问，只能互斥访问，所以破坏互斥条件来预防死锁，这不太可能。

##### （2）破坏请求和保条件：

可采用预先静态分配方法，即要求进程在运行之前一次申请它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦运行后，这些资源全归其占有，同时它也不再提出其它资源要求，这样可以保证系统不会发生死锁。此方法虽简单安全，但降低了资源利用率，同时必须预知进程所需要的全部资源。

##### （3）破坏不可剥夺条件：

即一个已经获得某些资源的进程，若又请求新的资源时不能得到满足，则它必须释放出已获得的所有资源，以后需要资源时再请求。也即一个进程已获得的资源在运行过程中可被剥夺。从而破坏了该条件。但这种方法实现较复杂，会增加系统开销，降低系统吞吐量。

##### （4）破坏环路条件：

可采用有序资源分配方法，即将系统中的所有资源都按类型赋予一个编号，要求每一个进程均严格按照编号递增的次序来请求资源，同类资源一次申请完。也就是，只要进程提出请求资源Ri，则在以后的请求中，只能请求Ri后的资源，这样不会出现几个进程请求资源而形成环路。该方法虽提高了资源的利用率，但编号难，加重进程负担及因使用资源顺序与申请顺序不同而造成资源浪费。

#### 死锁的避免

在死锁预防的几种方法中，都施加了较强的限制条件，严重降低了系统性能。在死锁避免的方法中，所施加的限制条件较弱，对于进程发出的每一个资源申请命令实施动态检查，并根据检查结果决定是否实施资源分配。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可以避免死锁的发生。

##### 系统的安全状态

      指在某一时刻，系统能按某种进程顺序(p1,p2,…，pn)来为每个进程Pi分配其资源,直到满足每个进程对资源的最大需求,使每个进程都可顺利地完成，则称此时的系统状态为安全状态称序列(p1,p2,…，pn)为安全序列。若某一时刻系统中不存在这样一个安全序列，则称此时的系统状态为不安全状态。

注：在死锁避免的方法中，允许进程动态申请资源，系统在进行资源分配之前，先计算资源分配的安全性，若此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则进程等待。

##### 基本事实

如果一个系统在安全状态，就没有死锁
如果一个系统处于不安全状态，就有可能死锁
避免死锁的实质：确保系统不进入不安全状态）

#### 避免死锁的算法-银行家算法

具有代表性的避免死锁算法，是Dijkstra给出的银行家算法，为实现银行家算法，系统中必须设置若干数据结构。假定系统中有n个进程（P1，P2，…，Pn），m类资源（R1，R2，…，Rm），银行家算法中使用的数据结构如下：
可利用资源向量:available[j]=k, 资源Rj类有k个可用
最大需求矩阵:Max[i,j]=k,进程Pi最大请求k个Rj类资源
分配矩阵：Allocation[i,j]=k,进程Pi分配到k个Rj类资源
需求矩阵：Need[i,j]=k,进程Pi还需要k个Rj类资源
		三个矩阵的关系：
Need [i,j] = Max[i,j] – Allocation [i,j].

##### 资源分配算法

设Requesti是进程Pi的请求向量，设Requesti [j] =k，表示进进程Pi请求分配Rj类资源k个。当进程Pi 发出资源请求后，系统按如下步骤进行检查：
(1)如Requesti[j]≤Need[i,j],转(2);否则出错，因为进程申请资源量超过它申明的最大量。
(2)如Requesti[j] ≤Available[j],转(3);否则表资源不够,需等待。
(3)系统试分配资源给进程Pi,并作如下修改：
Available[j]= Available[j]- Requesti[j]
Allocation[i,j]= Allocation[i,j]+ Requesti[j]
Need[i,j]= Need[i,j]- Requesti[j]
(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全,则正式进行分配,否则恢复原状态让进程Pi等待。

##### 安全性检查算法

为了进行安全性检查，需要定义如下数据结构：
int work[m]   工作变量，记录可用资源，开始时， Work= Available
int finish[n]  工作变量，记录进程是否进行完,开始时, finish[i]=false;当有足够资源分配给进程Pi时，令finish[i]=true。

#### 死锁的检测和解除

           如果在一个系统中，即未采用死锁预防方法，也未采用死锁避免方法，而是直接为进程分配资源，则系统中便有可能发生死锁。一旦死锁发生，系统应能将其找到并加以消除，为此需提供死锁检测和解除的手段。
#### 一、资源分配图

​          检测死锁的基本思想: 是在操作系统中保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁。为此，将进程和资源间的申请和分配关系描述成一个有向图---资源分配图。

#####  重要结论：

如果资源分配图中不存在环路，则系统中不存在死锁；反之，如果资源分配图中存在环路，则系统中可能存在死锁，也可能不存在死锁。

##### 资源分配图的化简

<span id='chapter4'></span>

## 第4章 存储器管理

存储器是计算机系统的重要组成部分，是计算机系统中的一种宝贵而紧俏的资源。操作系统中的存储管理是指对内存的管理，它是操作系统的重要功能之一。
存储管理的主要任务是为多道程序提供良好的运行环境，方便用户使用存储器，提高存储器的利用率以及从逻辑上扩充存储器。

为此存储管理应具有以下功能:

1. 实现内存的分配和回收
2. 地址变换（相对地址←→绝对地址）
3. “扩充”内存容量
4. 进行存储保护

#### 程序的装入和链接

##### 1、绝对装入方式

如果在编译时，事先知用户程序在内存的驻留位置，则编译程序在编译时就产生绝对地址的目标代码。装入程序就直接把装入模块中的程序和数据装入到指定的位置，（不需进行地址转换）
该装入方式只适用于单道程序环境。

##### 2、可重定位装入方式

重定位：由于一个作业装入到与其地址空间不一致的存储空间所引起的需对其有关地址部分进行调整的过程就称为重定位（实质是一个地址变换过程/地址映射）。  根据地址变换进行的时间及采用技术手段不同，可分为静态重定位和动态重定位两类。
可重定位装入方式：事先不知用户程序在内存的驻留位置，装入程序在装入时根据内存的实际情况把相对地址（逻辑地址）转换为绝对地址，装入到适当的位置。（在装入时进行地址转换）
用于多道程序环境

##### 3、动态运行装入方式

如果事先不知用户程序在内存的驻留位置，为了保证程序在运行过程中，它在内存中的位置可经常改变。装入程序把装入模块装入内存后，并不立即把装入模块中相对地址转换为绝对地址，而是在程序运行时才进行。这种方式需一个重定位寄存器来支持。（在程序运行过程中进行地址转换）

### 连续分配存储管理方式

连续/分区分配方式: 指为一个用户程序分配一片连续的内存空间

#### 一、单一连续分配方式（单独分区分配）

     最简单的一种存储管理方式，但只能用于单用户、单任务的OS中（为什么？）。
##### 存储管理方法：

将内存分为系统区（内存低端，分配给OS用）和用户区（内存高端，分配给用户用）。采用静态分配方式，即作业一旦进入内存，就要等待它运行结束后才能释放内存。

##### 主要特点：

管理简单，只需小量的软件和硬件支持，便于用户了解和使用。但因内存中只装入一道作业运行，内存空间浪费大，各类资源的利用率也不高。

#### 分区分配方式存储管理

         分区分配方式是满足多道程序设计需要的一种最简单的存储管理方法。
存储管理方法
           将内存分成若干个分区（大小相等/不相等），除OS占一区外，其余的每一个分区容纳一个用户程序。按分区数目的变化情况，可将分区存储管理进一步分为：
固定分区存储管理
动态分区存储管理

#### 二、固定分区分配方式（固定分区存储管理）

         是最早使用的一种可运行多道程序的存储管理方法。
##### 存储管理方法

内存空间的划分：将内存空间划分为若干个固定大小的分区，除OS占一区外，其余的一个分区装入一道程序。分区的大小可以相等，也可以不等，但事先必须确定，在运行时不能改变。即分区大小及边界在运行时不能改变。
系统需建立一张分区说明表或使用表，以记录分区号、分区大小、分区的起始地址及状态（已分配或未分配）。

##### 内存分配

当某个用户程序要装入内存时，由内存分配程序检索分区说明表，从表中找出一个满足要求的尚未分配的分区分配该程序，同时修改说明表中相应分区的状态；若找不到大小足够的分区，则拒绝为该程序分配内存。
当程序执行完毕，释放占用的分区，管理程序将修改说明表中相应分区的状态为未分配，实现内存资源的回收。

##### 主要特点：

管理简单，但因作业的大小并不一定与某个分区大小相等，从而使一部分存储空间被浪费。所以主存的利用率不高。

#### 三、动态分区分配方式

       动态分区分配又称为可变式分区分配，是一种动态划分存储器的分区方法。
##### 存储管理方法

​     不事先将内存划分成一块块的分区，而是在作业进入内存时，根据作业的大小动态地建立分区，并使分区的大小正好适应作业的需要。因此系统中分区的大小是可变的，分区的数目也是可变的。  

##### 主要特点

​      管理简单，只需小量的软件和硬件支持，便于用户了解和使用。进程的大小与某个分区大小相等，从而主存的利用率有所提高。

##### 1、分区分配中的数据结构

###### 空闲分区表

​     用来登记系统中的空闲分区(分区号,分区起始地址,分区大小及状态).  

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143913578-1864004301.png)


###### 空闲分区链

​       用链头指针将系统中的空闲分区链接起来，构成空闲分区链。每个空闲分区的起始部分存放相应的控制信息(如大小,指向下一空闲分区的指针等).

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143922144-781287364.png)


#### 2、分区分配算法

##### 首次适应算法（最先适应算法）

​     空闲分区（链）按地址递增的次序排列。在进行内存分配时,从空闲分区表/链首开始顺序查找,直到找到第一个满足其大小要求的空闲分区为止。然后再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲分区表（链）中。  

###### 首次适应算法的特点

​      优先利用内存低地址部分的空闲分区,从而保留了高地址部分的大空闲区。但由于低地址部分不断被划分,致使低地址端留下许多难以利用的很小的空闲分区(碎片或零头),而每次查找又都是从低地址部分开始,这无疑增加了查找可用空闲分区的开销。

##### 循环首次适应算法

又称为下次适应算法，由首次适应算法演变而来。在为作业分配内存空间时,不再每次从空闲分区表/链首开始查找,而是从上次找到的空闲分区的下一个空闲分区开始查找,直到找到第一个能满足其大小要求的空闲分区为止。然后，再按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲分区表/链中。

###### 算法特点

​       使存储空间的利用更加均衡，不致使小的空闲区集中在存储区的一端，但这会导致缺乏大的空闲分区。

##### 最佳适应算法

###### 算法要求：

​             空闲分区/链按容量大小递增的次序排列。在进行内存分配时，从空闲分区表/链的首开始顺序查找，直到找到第一个满足其大小要求的空闲分区为止。
​       按这种方式为作业分配内存，就能把既满足作业要求又与作业大小最接近的空闲分区分配给作业。

###### 算法特点

​       若存在与作业大小一致的空闲分区,则它必然被选中，若不存在与作业大小一致的空闲分区，则只划分比作业稍大的空闲分区，,从而保留了大的空闲分区,但空闲区一般不可能正好和它申请的内存空间大小一样,因而将其分割成两部分时,往往使剩下的空闲区非常小,从而在存储器中留下许多难以利用的小空闲区（碎片或零头）。

##### 最坏适应算法

###### 算法要求

​      空闲分区/链按容量大小递减的次序排列。在进行内存分配时，将第一个（即最大的）空闲分区分割给作业使用。

###### 算法特点

​    总是挑选满足作业要求的最大的分区分配给作业。这样使分给作业后剩下的空闲分区也较大，可装下其它作业。但由于最大的空闲分区总是因首先分配而划分，当有大作业到来时，其存储空间的申请往往会得不到满足。

#### 3、分区分配操作_分配内存和回收内存

##### （1）分配内存

​      系统利用某种分配算法，从空闲分区表/链中找到所需大小的分区。

######   分区的切割：

​      设请求的分区大小为u.size，空闲分区的大小为m.size,若m.size-u.size<=size(size是事先规定的不再切割的剩余分区的大小)，说明多余部分大小，可不再切割，将整个分区分配给请求者；否则，从该分区中按请求的大小划分出一块内存空间分配出去，余下的部分仍留在空闲分区表/链中，然后，将分配区的首址返回给调用者。
 分配流程图如下 

##### （2）回收内存

         当作业执行结束时，应回收已使用完毕的分区。系统根据回收分区的大小及首地址，在空闲分区表中检查是否有邻接的空闲分区，如有，则合成为一个大的空闲分区，然后修改有关的分区状态信息。
###### 回收分区与已有空闲分区的相邻情况有以下四种：

   1）回收分区上邻接一个空闲分区,合并后首地址为空闲分区的首地址,大小为二者之和。
    2）回收分区下邻接一个空闲分区,合并后首地址为回收分区的首地址,大小为二者之和。
    3）回收分区上下邻接空闲分区,合并后首地址为上空闲分区的首地址,大小为三者之和。 
    4）回收分区不邻接空闲分区，这时在空闲分区表中新建一表项，并填写分区大小等信息。

#### 四、可重定位分区分配方式

##### 1、碎片问题          

​           在分区存储管理方式中，必须把作业装入到一片连续的内存空间。如果系统中有若干个小的分区，其总容量大于要装入的作业，但由于它们不相邻接，也将致使作业不能装入内存。
例 ：如图所示系统中有四个小空闲分区，不相邻，但总容量为90KB，如果现有一作业要求分配40KB的内存空间，由于系统中所有空闲分区的容量均小于40KB，故此作业无法装入内存。
​           这种内存中无法被利用的存储空间称为“零头”或“碎片”.根据碎片出现的情况分为以下两种：

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143929975-644457008.png)


##### 系统中的碎片

内部碎片：指分配给作业的存储空间中未被利用的部分。
              	如固定分区中存在的碎片。
外部碎片：指系统中无法利用的小的空间分区。
              	如动态分区中存在的碎片。

##### 2、碎片问题的解决方法

       对系统中存在碎片，目前主要有两种分区重定位技术：
###### 拼接或紧凑或紧缩技术

​           将内存中所有作业移到内存一端（作业在内存中的位置发生了变化，这就必须对其地址加以修改或变换即称为重定位），使本来分散的多个小空闲分区连成一个大的空闲区。如图所示。这种通过移动作业从把多个分散的小分区拼接成一个大分区的方法称为拼接或紧凑或紧缩。
​            拼接时机：分区回收时；当找不到足够大的空闲分区且总空闲分区容量可以满足作业要求时。

###### 可重定位分区分配方式主要特点

​        可以充分利用存储区中的“零头/碎片”，提高主存的利用率。 但若 “零头/碎片”大多，则拼接频率过高会使系统开销加大。

#### 五、分区的存储保护

           存储保护是为了防止一个作业有意或无意地破坏操作系统或其它作业，常用的存储保护方法有：
##### 1、界限寄存器方法

 上下界寄存器方法：用这两个寄存器分别存放作业的起始地址和结束地址。在作业运行过程中，将每一个访问内存的绝对地址都同这两个寄存器的内容比较，如超出这个范围便产生保护性中断。
基址、限长寄存器方法：用这两个寄存器分别存放作业的起始地址和作业的地址空间长度。当作业执行时，将每一访问内存的相对地址和限长寄存器比较，如果超过了限长寄存器的值，则发出越界中断信号，并停止作业的运行。

##### 2、存储保护键方法

给每个存储块（大小相同，一个分区为整数倍存储块）分配一个单独的保护键，它相当于一把锁。进入系统的每个作业也赋予一个保护键，它相当于一把钥匙。当作业运行时，检查钥匙和锁是否匹配，如果不匹配，则系统发出保护性中断信号，停止作业运行。

#### 六、覆盖与交换

      覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。覆盖技术主要用在早期的OS中，而交换技术则主要用在现代OS中，解决在小的内存空间运行大作业的问题。是“扩充”内存容量和提高内存利用率的有效措施。
##### 1、覆盖技术

​      覆盖技术主要用在早期的OS中（内存<64KB），可用的存储空间受限，某些大作业不能一次全部装入内存，产生了大作业与小内存的矛盾。
 例：

覆盖：把一个程序划分为一系列功能相对独立的程序段（称为覆盖），让执行时并不要求同时装入内存的覆盖组成一组（称为覆盖段），共享主存的同一个区域，从而解决在小的存储空间中运行大作业问题。这种内存扩充技术就是覆盖。

##### 2、交换/对换

      交换技术也是“扩充”内存容量和提高内存利用率的有效措施。现代OS中广泛采用。
       最早用在MIT的兼容分时系统CTSS中，任何时刻系统中只有一个完整的用户作业，当运行一段时间后，因时间片用完或等待某事件发生，系统就把它交换到外存上，同时把另一作业调入内存让其运行，这样，可以在内存容量不大的小型机上分时运行，早期的一些分时系统多数采用这种交换技术。
##### 交换与覆盖技术的区别

​       交换技术不要求程序员给出程序段之间的覆盖结构，交换主要交换主要在作业或进程之间进行。
​       覆盖技术要求程序员必须把一个程序划分成不同的程序段，并规定好它们的执行和覆盖顺序，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。覆盖技术主要在同一个作业或进程中进行，同时覆盖只能覆盖与覆盖程序段无关的程序段。

### 基本分页存储管理方式

在分页存储管理方式中，如不具备页面对换功能，不支持虚拟存储器功能，在调度作业运行时，必须将它的所有页面一次调入内存，若内存没有足够的块，则作业等待，这种存储管理方式称为纯分页或基本分页存储管理方式 。

#### 一、基本思想

##### 空间划分

​     （1）将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,并为各页从0开始编号。
​     （2）内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。

##### 内存分配

​      在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。

#### 二、地址结构

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143940972-772734007.png)


##### 二、地址结构例题

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143951003-1929887257.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115143958135-2105420705.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144004126-1633779623.png)


#### 四、地址变换机构

       为了能将用户地址空间中的逻辑地址变换为内存空间中的物理地址，在系统中必须设置地址变换机构。分基本的地址变换机构和具有快表的地址变换机构。
地址变换机构的基本任务
   ------实现逻辑地址向物理地址的转换（页号->块号）。
    地址变换借助页表来完成。
分页系统的基本地址变换机构如图所示：

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144023731-1947884061.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144029195-1947185968.png)


#### 四、地址变换机构                -----具有快表的地址变换机构

##### 基本的地址变换机构存在的问题

地址变换速度降低（因页表放于内存中，CPU访问一个字节的数据需两次访问内存）

##### 目的：为提高地址变换速度

##### 快表（联想寄存器、联想存储器、TLB）

为一种特殊高速缓冲存储器。
内容--为页表中的一部分或全部
CPU产生的逻辑地址的页首先在快表中寻找，若找到（命中），就找出其对应的物理块；若未找到（未命中），再到页表中找其对应的物理块，并将之复制到快表。
若快表中内容满，则按某种算法淘汰某些页。

#### 四、页的共享保护

### 基本分段存储管理方式

### 利用段表和页表实现地址映射

### 虚拟存储器的引入

常规存储器管理方式的特征
   （1）一次性：作业在运行前需一次性地全部装入内存。将导致上述两问题。
   （2）驻留性：作业装入内存后，便一直驻留内存，直至作业运行结束。
局部性原理
      指程序在执行时呈现出局部性规律，即在一较短时间内，程序的执行仅限于某个部分，相应地，它所访问的存储空间也局限于某个区域。
       局部性又表现为时间局部性(由于大量的循环操作，某指令或数据被访问后，则不久可能会被再次访问)和空间局部性（如顺序执行，指程序在一段时间内访问的地址，可能集中在一定的范围之内）。

### 虚拟存储器的概念

基于局部性原理，程序在运行之前，没有必要全部装入内存，仅须将当前要运行的页（段）装入内存即可。
运行时，如访问的页（段）在内存中，则继续执行，如访问的页未在内存中（缺页或缺段），则利用OS的请求调页（段）功能，将该页（段）调入内存。 
如内存已满，则利用OS的页（段）置换功能，按某种置换算法将内存中的某页（段）调至外存，从而调入需访问的页。       
       虚拟存储器是指仅把作业的一部分装入内存便可运行作业的存储管理系统，它具有请求页调入功能和页置换功能，能从逻辑上对内存容量进行扩充，其逻辑容量由外存容量和内存容量之和决定，其运行速度接近于内存，成本接近于外存。

### 二、请求分页中的内存分配策略和分配算法

### 三、 请求分页中的页面调入策略

### 4.7 请求分页中的页面置换算法

常用的页面置换算法：  

最佳置换算法：选择永远不再需要的页面或最长时间以后才需要访问的页面予以淘汰。
先进先出置换算法：选择先进入内存的页面予以淘汰。
最近最久未使用置换算法LRU：选择最近一段时间最长时间没有被访问过的页面予以淘汰。
*其它算法

#### 最佳置换算法例

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144037058-1200610329.png)


### 最近最久未使用算法

### 请求分段式存储管理方式

<span id='chapter5'></span>

## 第5章  设备管理

### I/O 系统

I/O 系统的组成: I/O设备、设备控制器、 I/O通道*、总线及相应软件

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144044198-1219985522.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144051408-427983657.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144056841-62896708.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144103432-1046115126.png)


### 设备与控制器之间的接口 

#### 设备控制器

​           是处于CPU与I/O设备之间的接口，接收CPU发来的命令，并控制I /O设备工作，是一个可编址设备。

####  功能：

接收和识别命令、实现数据交换、了解设备状态以及识别设备地址。 
设备控制器的组成
设备控制器与处理机的接口
设备控制器与设备接口

#### I/O逻辑

寄存器：控制寄存器(存放命令及参数)、数据寄存器(存放数据)、状态寄存器(记录设备状态).

### I/O 通道

根据信息交换方式的不同，通道可分成以下几种类型：

#### 字节多路通道

其工作原理:  数据传送是按字节交叉方式工作。
1)有一个主通道。
2)含有多个子通道A、B、C……
3)每子通道通过一控制器与一台中/低速的I/O设备相连，可同时发行向主通道传数据。
4)各子通道以时间片轮转方式按字节交叉使用主通道。
优点：可连多台中/低速设备；能分时并行操作。
缺点：传输率较低。 

#### 数组多路通道

​     数据传送仍是按数组方式工作。

​    工作原理（结合两者：并发+数组）

​         1)有一个主通道

​         2)含有多个子通道A、B、C……

​         3)每子通道通过一控制器与一台**高****/****中速**的I/O设备相连，可同时并发向主通道传数据。

​         4)各子通道以时间片轮转方式按数组方式使用主通道。

v优点：可连多台高/中速设备；能分时并行操作，传输率较高。

### I/O 控制方式

常用的输入/输出控制方式：
  1、程序控制方式
  2、中断控制方式
  3、直接存储器访问DMA方式
  4、通道控制方式 

#### 1、程序直接控制方式

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144111788-769307780.png)


#### 2、中断控制方式

１）需数据的进程向CPU发出指令启动I/O设备输入数据。
２）该进程放弃处理机，等待输入完成。
３）输入完成后，I/O控制器向CPU发出中断请求，CPU收到后，转向中断服务程序。中断服务程序将数据输入寄存器中的数据送指定内存单元，并将原进程唤醒，继续执行。
４）在以后，该进程再被调度，从内存单元取出数据进行处理。
   优点—CPU利用率大大提高（可以与I/O设备并行工作）。
   缺点---若中断次数较多将耗去大量CPU处理时间。

#### 3、DMA方式

1）需数据的进程向CPU发出指令,向DMA控制器写入数据存放的内存始址、传送的字节数,并置中断位和启动位,启动I/O设备输入数据并允许中断。
2）该进程放弃处理机等待输入完成，处理机被其它进程占据。
3）DMA控制器采用挪用存储器周期，将一批数据写入内存中。
4）DMA控制器传送完数据后，向CPU发中断请求，CPU响应后转向中断服务程序，唤醒进程，并返回被中断程序。
5）在以后该进程再被调度，从内存单元取出数据进行处理。
优点—CPU利用率进一步提高（并行度有所提高）。
缺点—数据传送方向、字节数、内存地址等需由CPU控制，且每一设备需一台DMA控制器，设备增多时，不经济。

#### 4、通道控制方式

1）需数据的进程向CPU发出指令，CPU发启动指令指明I/O操作、设备号和对应的通道。
2）该进程放弃CPU等待输入完成，CPU被其它进程占据。
3）通道接收到CPU发来的启动指令后，取出内存中的通道程序执行，控制设备将数据传送到内存指定区域。
4）传送完数据后，通道向CPU发中断请求，CPU响应后转向中断服务程序，唤醒进程，并返回被中断程序。
5）在以后该进程再被调度，从内存取出数据进行处理。
优点—一个通道可控制多设备，所需CPU干预更少。
            CPU利用率较高（并行度较高）。
缺点：通道价格较高。

### 缓冲管理

1、提高处理机与I/O设备的并行工作的技术：
     １）  数据传送控制方式      ２）  缓冲技术
2、操作系统中，引入缓冲的主要原因
      1）缓冲CPU与I/O设备间速度不匹配的矛盾。
      2）减少中断CPU的次数
      3）提高CPU与I/O设备的并行性
3、缓冲实现方法两种：
    1）采用硬件缓冲器实现
    2）用软件缓冲区来实现

缓冲就是用来对数据传送速度不同的设备的传送速度进行匹配/缓冲的一种常用手段。其实现方法除在关键地方可采用硬件缓冲器外，大都采用软件缓冲来实现。软件缓冲区是指在I/O操作期间，专门用来临时存放输入/输出数据的一块存储区域。
4、缓冲技术的分类
       单缓冲                  双缓冲
       循环缓冲               缓冲池 

#### 单 缓 冲

         在设备和处理机之间设置一个缓冲。设备与处理机交换数据时，先把交换的数据写入缓冲区，然后需要数据的设备/处理机再从缓冲区中取走数据。
           特点：缓冲区数只有一个；设备与处理机对缓冲区的操作是串行的。 
#### 双 缓 冲

      在设备和处理机之间设置两个缓冲。设备与处理机交换数据时，先把交换的数据写入缓冲区，然后需要数据的设备/处理机再从缓冲区中取走数据。因缓冲区有2个，提高了设备与处理机并行操作的程度，只有当两个均为空时，需数据的进程才等待。

特点：缓冲区数有2个；设备与处理机对缓冲区的操作可并行，提高了设备与处理机并行操作的程度。

#### 循 环 缓 冲

       在设备和处理机之间设置多个大小相等的缓冲区，这些缓冲区构成环形，每一个缓冲区中含一指针指向下一个缓冲区，最后一个指向第一个缓冲区，同时还含有2个用于输入/输出的指针IN和OUT。
    特点：缓冲区数有多个；设备与处理机对缓冲区的操作可并行，进一步提高了设备与处理机并行操作的程度。  
### 缓 冲 池

1、缓冲池：将系统内所有的缓冲区统一管理起来，就形成了能用于输入/输出的缓冲池。缓冲池通常由若干大小相同的缓冲区组成，是系统的公用资源，任何进程都可以申请使用缓冲池中的各个缓冲区。
2、缓冲池的组成（数据结构）
       三个队列：空缓冲队列、装满输入数据队列、装满输出数据队列
       四个工作缓冲区： 收容输入缓冲区、提取输入
                                          收容输出、提取输出缓冲区 

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144118835-1023573347.png)


### 设备分配

●设备分配中的数据结构
●设备分配的策略/应考虑的因素
● 设备独立性
●设备分配程序
●SPOOLING技术 

#### 7.4 .1 设备分配中的数据结构

设备控制表DCT(device control table)
控制器控制表COCT(controller control table)
通道控制表CHCT（channel control table）
系统设备表SDT(system device table)

#### 5.4 .2    设备分配策略/应考虑的因素

1、设备的使用性质/固有属性
         （独享分配 、共享分配、虚拟分配） 
2、设备分配算法
         （先请求先服务、优先级高者优先 ）
3、设备分配的安全性（防止进程死锁）
4、设备独立性 ：是指用户在编制程序时所用的设备(逻辑)与实际使用的设备无关 

##### 先请求先服务

当有多进程对同一设备提出I/O请求时，系统根据这些进程发出请求的先后次序将它们排成一个设备请求队列，设备分配程序总是把设备分配给队首的进程。

##### 优先级高者优先

按照进程优先级的高低进行分配。即当多进程对同一设备提出I/O请求时，谁优先级高，就将设备分配给谁。若优先级相同，则按先请求先服务进行分配。

#### 5.4 .3     设备独立性

##### 设备独立性概念（设备无关性）

##### 设备独立性的实现

###### 逻辑设备（应用程序）和物理设备（执行）

设备分配时的灵活性
易于实现I/O重定向

###### 设备独立性软件

执行所有设备的公有操作
向用户层（文件层）软件提供统一的接口

###### 逻辑设备名到物理设备名映射的实现

逻辑设备表LUT(Logical Unit Table)
LUT设置问题(图5-8)
           整个系统设置一张LUT ；每个用户设一张LUT 

##### 设备独立性概念（设备无关性）

​          为提高OS的可适应性和可扩展性，而将应用程序独立于具体使用的物理设备。

##### I/O重定向

​        指用于I/O操作的设备可以更换，即重定向，而不必改变应用程序。

##### 所有设备的公有操作

​          独立设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护（禁直访）；缓冲管理；差错控制。

#### 5.4.4   独占设备的分配程序

##### 基本的设备分配程序

分配设备
分配控制器
分配通道
问题（“瓶颈”）
	进程以物理设备名来提出I/O请求
	采用的是单通路的I/O系统结构

##### 设备分配程序的改进

增加设备的独立性(进程以逻辑设备名来提出I/O请求)
考虑多通路情况

#### SPOOLING技术(Simultaneaus Periphernal Operations On-Line)

##### 脱机输入、输出技术

​      为了缓和CPU的高速性与I/O设备的低速性间矛盾而引入，该技术在外围控制机的控制下实现低速的I/O设备与高速的磁盘之间进行数据传送。

##### SPOOLING技术

##### SPOOLING系统的组成

##### SPOOLING系统的特点

提高了I/O速度
将独占设备改造为共享设备
实现了虚拟设备功能

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144125248-1452461726.png)


#### 在操作系统中，引入虚拟设备的原因

​      引入虚拟设备是为了克服独占设备速度较慢、降低设备资源利用率的缺点，从而提高设备的利用率。

#### 虚拟设备

​       是指通过虚拟技术将一台独占设备变换为若干台逻辑设备，供若干个用户进程使用，通常把这种经过虚拟技术处理后的设备称为虚拟设备。

### 设备处理

##### 设备驱动程序的功能和特点

设备驱动程序的功能
设备处理方式
设备驱动程序的特点

##### 设备驱动程序的的处理过程

##### 中断处理程序的处理过程

#### 设备驱动程序的功能

将接收到的抽象要求转换为具体要求。
检查用户I/O请求的合法性，I/O设备状态，传参数，设设备的工作方式。
按处理机的I/O请求去启动指定的设备进行I/O操作
及时响应由控制器或通道发来的中断请求，并进行相应处理
按I/O请求构成相应通道程序。

#### 设备处理方式

为每一类设备设置一进程，专门执行其I/O操作。
在整个系统中设置一个进程，执行所有的I/O操作。 
不设置专门的设备处理进程，而为各类设备设置相应的设备驱动程序。

#### 设备驱动程序的特点

是请求I/O的进程与设备控制器之间的一个通信与转换程序。
与I/O设备的特性紧密相关
与I/O控制方式紧密相关
与硬件紧密相关，因而其中一部分程序必须用汇编语言编写。

#### 设备驱动程序的的处理过程

将接收到的抽象要求转换为具体要求。
检查用户I/O请求的合法性
读出和检查 I/O设备状态
传送必要参数
设置设备的工作方式。
按处理机的I/O请求去启动指定的设备进行I/O操作。

#### 中断处理程序的处理过程

唤醒被阻塞的驱动程序进程
保护被中断进程的CPU环境
分析中断原因、转入相应的设备中断处理程序
进行中断处理
恢复被中断进程的现场

### 5.6    磁盘存储器

提高磁盘I/O速度的主要途径：
（1）选择性能好的磁盘
（2）采用好的磁盘调度算法
（3）设置磁盘高速缓存（Disk Cache）
（4）其它方法
（5）采用高度可靠、快速的容量磁盘系统_____谦价磁盘冗余阵列

#### 1、磁盘性能

##### 磁盘性能简述

##### 数据的组织

磁盘结构、磁道、柱面、扇区、磁盘格式化
磁盘物理块的地址：  柱面号   磁头号    扇区号

##### 磁盘类型

（固定头磁盘、移动头磁盘）

##### 访问时间

寻道时间：将磁头从当前位置移到指定磁道所经历时间
旋转延迟时间：指定扇区移动到磁头下面所经历时间
传输时间：将扇区上的数据从磁盘读出/向磁盘写入数据所经历的时间。

#### 2、  磁盘调度算法

##### 磁盘调度算法

##### 早期的磁盘调度算法

先来先服务FCFS
最短寻道时间优先SSTF

扫描算法

扫描(SCAN)算法
循环扫描(CSCAN)算法
**N-STEP-SCAN调度算法

##### **SSTF、SCAN及CSCAN存在的问题---磁臂粘着

​           在SSTF、SCAN及CSCAN几种调度算法中，可能出现磁臂停留在某处的情况，即反复请求某一磁道，从而垄断了整个磁盘设备，这种现象称为磁臂粘着。
N-STEP-SCAN调度算法
​      将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列，而每一子队列按SCAN算法处理。
​        N=1               FCFS算法
​        N很大             SCAN算法
​        N取半长度         FSCAN算法

#### 3、设置磁盘高速缓存（Disk Cache）

      目前，由于磁盘的I/O速度远低内存的访问速度，而致使磁盘的I/O成为计算机系统的瓶颈。为提高磁盘的I/O速度，便采用磁盘高速缓存。
磁盘高速缓存的形式 
数据交付方式
置换算法
周期性地写回磁盘

##### (1)磁盘高速缓存的形式

######  磁盘高速缓存

是指内存中的一部分存储空间，用来暂存从磁盘读出的一系列盘块中的信息。所以它是一组在逻辑上属于磁盘，而物理上是驻留在内存中的盘块。

###### 磁盘高速缓存的形式

内存中单独的存储空间（大小固定）
未利用的存储空间__缓冲池（大小不固定）           

##### (2)数据交付方式

##### (3)置换算法

          在将磁盘中的盘块读入到磁盘高速缓存中时，若因磁盘高速缓存已满，则采用常用的算法进行置换：
最近最久未使用算法LRU     
最近未使用算法NRU
最少使用算法LFU

###### 置换时除算法外还应考虑的问题

访问频率
可预见性
数据的一致性 ___解决方法将系统中所有盘块数据，拉成一条LRU链，对将会严重影响到数据一致性的数据和很久都可能不再使用的盘块数据， 放在LRU头部，到时优先写回磁盘。

##### (4)周期性地写回磁盘

#### 4、提高磁盘I/O速度的其它方法 

##### 提前读（Read_Ahead）

​      由于用户对文件的访问常用顺序方式，在读当前块时，可预知下一次要读的盘块，所以，可采用预先读方式，即在读当前块的同时，连同将下一块提前读入缓冲。当访问下一块数据时，其已在缓冲中，而不需去启动磁盘I/O。

##### 延迟写

​       在缓存中的数据,本应立即写回磁盘,考虑不久之后可能会再用,故不立即写回磁盘。
优化物理块的分布 使磁头移动的距离最小（优化物理块的分布、优化索引结点的分布）。

##### 虚拟盘 

​    利用内存去访真磁盘，又称为RAM盘。（与磁盘高速缓存的区别：RAM盘中的内容由用户控制，而缓存中的内容则由OS控制）

#### 5、谦价磁盘冗余阵列（RAID）

      是1987年由美国加利福尼来大学伯莱分校提出的，1988年问世，即利用一台磁盘陈列控制器，来统一管理和控制一组磁盘驱动器，组成一个高度可靠的、快速的大容量磁盘系统。
并行交叉存取 
RAID的分级
RAID的优点

谦价磁盘冗余阵列（ RAID ）的优点 

##### 可靠性高     

​        是RAID 的最大优点（除RAID 0 级外）

##### 磁盘I/O速度高    

​     由于RAID 可采用并行交叉存取方式，故提高了磁盘I/O速度。

##### 性能/价格比高 

​     用RAID技术实现大容量存储器时，与大型磁盘系统相比，其体积和价格只是它的1/3，且可靠性高。

### 5.7   UNIX系统中的设备管理

<span id='chapter6'></span>

### 第6章  文件系统

文件系统的功能/需解决的问题

##### 从系统角度看

负责为用户建立、删除、读写、修改和复制文件。

##### 从用户的角度看：

实现了按名存取。

#### 一、数据的组成

##### 数据项

基本数据项（最小的逻辑数据单位）
组合数据项

##### 记录

是一组相关数据项的集合

##### 文件

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144132876-1536131941.png)


![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144138212-1215025807.png)


### 三、文件系统模型

![](https://img2018.cnblogs.com/blog/1545358/202001/1545358-20200115144143466-764748937.png)


### 四、文件操作

    用户通过文件系统所提供的接口实施对文件的操作。最基本的操作有：
##### 对记录的操作：检索、插入、修改、删除

##### 对文件的操作

最基本的： 创建 、打开、关闭、删除 、读 、写 、截断
其它的：文件属性类操作、目录类操作

##### 文件的“打开”和“关闭”操作

​    “打开”：系统将文件的属性（目录信息）从外存复制到内存打开文件表中，并返回该表目的编号给用户，建立了用户与文件间的联系。以后若再访问此文件，则利用编号直接在内存中检索，从而节省大量的检索开销，提高了文件的操作速度。
​    “关闭”：当用户不再需要对该文件的操作时，系统利用关闭文件将文件的属性从内存打开表中删除，从而切断用户与文件间的联系。

### 6.2     文件逻辑结构

    对任一文件存在着两种形式的结构：
##### 文件的逻辑结构（文件组织）

​       从用户观点出发，所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于物理特性。

##### *文件的物理结构（文件的存储结构）

​        是指文件在外存上的存储组织形式，与存储介质的存储性能有关。（分为顺序、链接及索引结构）
注： 文件的逻辑结构和物理结构都将影响文件的检索速度。

##### 对文件的逻辑结构提出的要求：

​        提高检索；便于修改；降低文件存储费用。
文件逻辑结构的类型
顺序文件
索引文件
索引顺序文件

#### 一、文件逻辑结构的类型

##### 有结构的记录式文件

文件构成：由一个以上的记录构成。
记录长度：分为定长和变长。
分类（按记录的组织）：顺序文件
                                      索引文件
                                      索引顺序文件

##### 无结构的流式文件

文件构成：由字符流构成。
长度：字节为单位
访问：读写指针
注：Unix中所有文件视为流式文件

#### 二、顺序文件

##### 逻辑记录的排序

串结构：记录顺序与关键字无关，按存入时间的先后排列。
顺序结构：记录顺序按关键字排列。

##### 对顺序文件的读、写操作

记录为定长的顺序文件
记录为变长的顺序文件

#### 顺序文件的优缺点

##### 优

顺序存取速度较快（批量存取）。
对定长记录，还可方便实现直接存取。

##### 缺

对变长记录，直接存取低效
不利于文件的动态增长。

#### 三、索引文件

##### 引入

为解决变长记录文件的直接存取低效问题。

##### 索引文件

为变长记录文件建立一张索引表。

### 索引顺序文件的特点

##### 优点

通过索引表可方便地实现直接存取，具有较快的检索速度。
易于进行文件的增删。

##### 缺点

索引表的使用增加了存储费用;

索引表的查找策略对文件系统的效率影响很大.

注：若索引表很大，可建多级索引

### 6.3      外存分配方式

##### 文件存储单位：簇（cluster）

​      文件的存储空间通常由多个分立的簇组成，而每个簇包含若干个连续的扇区(sector)/块。

##### 目前常用的外存分配方法：

（1）连续分配（顺序分配）
（2）链接分配
（3）索引分配

#### （1） 外存分配方法-连续/顺序分配

Figure P214 6-7
为每一个文件分配一片连续的磁盘块/簇
只需要起始块/簇号和长度，适用于预分配方法
可以随机存取
文件不能增长
从逻辑地址映射到物理地址较简单
浪费空间：动态存储分配问题
可以通过紧缩(compact)将外存空闲空间合并成连续的区域。

#### 连续/顺序分配的主要优缺点

##### 主要优点

顺序访问容易
顺序访问速度快

##### 缺点

要求有连续的存储空间
必须事先知道文件的长度
存在外部碎片

#### （2）  外存分配方法-链接分配

Figure 215 6-8
每个文件是一个磁盘块的链接列表：块可以分散在磁盘各处
按所需分配磁盘块，链接在一起
在每个块中有指向下一个块的指针
只需要起始地址

可以通过合并(consolidation)将一个文件的各个簇连续存放，以提高I/O访问性能。

#### 链接分配的优缺点

##### 优点

1、无外部碎片，没有磁盘空间浪费
2、无需事先知道文件大小。文件动态增长时，可动态分配空闲块。对文件的增、删、改十分方便。
3、不需紧缩磁盘空间。

##### 缺点

1、不能支持高效随机/直接访问，仅对顺序存取特有效
2、需为指针分配空间。---块     簇       （隐式链接）
3、可靠性较低（指针丢失/损害）    
           文件分配表FAT
         FAT需占用较大的内存空间。            

#### （3）  外存分配方法-索引分配

### 6.4   目录管理

##### 对文件目录的管理要求

实现“按名存取”
提高对目录的检索速度
文件共享
允许文件重名

#### 文件控制块和索引结点

从文件管理角度看，文件由FCB和文件体（文件本身）两部分组成。 

##### 文件控制块（FCB）

文件控制块是操作系统为管理文件而设置的数据结构，存放了文件的有关说明信息,是文件存在的标志。

###### 文件目录

​      把所有的FCB组织在一起，就构成了文件目录，即文件控制块的有序集合。

###### 目录项

​       构成文件目录的项目（目录项就是FCB）

###### 目录文件

​       为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，这个文件就叫目录文件

##### FCB中的信息

基本信息类：文件名、文件长度、类型、属性文件物理位置
存取控制信息类：文件存取权限、用户名、口令、共享计数
使用信息类：文件的建立日期、最后修改日期、保存期限、
              最后访问日期,

#### 两级目录结构

##### 优点:

提高了检索目录的速度；
不同用户目录中可重名；
不同用户可用不同文件名来访问系统中一共享文件

##### 缺点: 

限制了各用户对文件的共享
增加了系统开销，缺乏灵活性，无法反映真实世界复杂的文件结构形式。

#### 树型目录结构

在两级目录中若允许用户建立自己的子目录，则形成3级或多级目录结构（即树型目录结构）

#### 目录查询技术

##### 数据文件（按名存取）的查询步骤

根据用户提供的文件名，对文件目录进行查询，找到该文件的FCB（索引结点）
根据FCB（索引结点）所记录的磁盘盘块号，换算出文件在磁盘上的物理位置
启动磁盘驱动程序，读该数据文件至内存中。

##### 对目录进行查询的方式

线性检索法（顺序检索法）
Hash方法

### 6.5    文件共享

早期实现文件共享的方法
绕弯路法（低效）
        允许每个用户获得一“当前目录”，用户所访问的所有文件均相对于当前目录，若不在，则“向上走”绕弯路去访问其上级目录。
连访法        
利用基本文件目录实现文件共享
基于索引结点的共享方式
利用符号链实现文件共享

### 6.5   文件保护

#### 影响文件安全性的主要因素

人为因素
系统因素
自然因素

#### 确保文件系统安全性的措施

存取控制机制------人为因素
系统容错技术------系统因素
后备系统------------自然因素

#### 6.5    文件保护---存取控制机制

##### 保护域

##### 访问矩阵

##### 访问矩阵的修改（拷贝权、所有权、控制权）

##### 访问矩阵的实现（访问控制表、访问权限表）

##### 分级安全管理

###### 系统级安全管理

使系统管理员能够掌握要使用系统的诸用户的情况，并保证用户名在系统中的唯一性。

###### 用户级安全管理

根据用户性质、需求及文件属性给用户分配“文件访问权” 。

###### 目录级安全管理

为保护系统中各种目录的安全，系统对目录操作指定了权限。

###### 文件级安全管理

通过系统管理员或文件主对文件属性的设置，来控制用户对文件的访问。

##### 磁盘容错技术

### 6.7  UNIX系统的文件管理

##### 对文件的管理

文件存储空间的管理
文件物理结构
用户文件描述符表和文件表的管理

##### 目录管理

对索引结点的管理
构造目录和删除目录

##### 检索目录

文件系统的系统调用


<span id='ps'></span>
## 附习题答案

[下载链接](https://www.lanzous.com/b00z6e8hg)
密码:ce89